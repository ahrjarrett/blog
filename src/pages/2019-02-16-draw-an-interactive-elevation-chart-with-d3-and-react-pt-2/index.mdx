---
path: "/2019-02-16-draw-an-interactive-elevation-chart-with-d3-and-react"
date: "2019-02-16"
title: "Draw an Interactive Elevation Chart with D3 & React, Part 2"
image: "/images/2019-02-16-draw-an-interactive-elevation-chart-with-d3-and-react-pt-2.gif"
tags: ["react", "d3", "javascript", "google maps", "data-visualization"]
excerpt: "Part 2: Data visualization is too fun. My team made an app that consumes a user’s trip data and uses it to draw cool stuff. Here’s how we used React, D3 and Google Maps to do it."
published: true
---

import MapWithMarkers from "../../components/maps/MapWithMarkers"
import LoadMapsApi from "../../components/maps/LoadMapsApi"
// import ElevationGraph from "../../components/d3/ElevationGraph"

import { markerPositionsNZ, mapCenterNZ } from "../../components/maps/data"

<LoadMapsApi />

## Drawing the Chart

This is a series on using D3, React and the Google Maps API to create data visualizations. We’ll be building an interactive, dynamic area chart that plots distance on the x-axis and elevation on the y-axis.

#### [Catch up on part 1 here!](https://blog.thegrepper.com/2019-02-11-draw-an-interactive-elevation-chart-with-d3-and-react)

First let’s remind ourselves what we’re building:

<iframe
  className="youtube-video"
  width="720"
  height="480"
  src="https://www.youtube.com/embed/9HXlmXwyuKk"
  frameBorder="0"
  allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
  allowFullScreen
/>

We’ve got 5 things to do, plus 1 bonus step to spruce up your chart’s appearance with gridlines that span across the x- and y-scales at each tick on the chart.

## 5 Steps + 1 Bonus

1. Declare our constants, helper functions, and configure D3 so it’s ready for action.
1. Map out our "ElevationGraph" component, including:

   <ul style={{ marginLeft: "3rem" }}>
     <li>– what lives on state & what comes on props?</li>
     <li>– decide which lifecycle methods we’ll need</li>
     <li>– name and pseudocode our custom methods</li>
   </ul>

1. Draw the chart using D3’s API! This is the fun part, and the meat and potatoes of our task today
1. Render that bad boy! We’ll talk styles here too, especially regarding svg styling (wtf is viewPort vs. viewBox, etc.)
1. Write a callback function that draws a DOM element on the map depending on where the user is hovering
1. [Bonus] Make it pretty

### 1. Declarations & Config

[WIP]

First we need some helper functions. This first batch is pure JavaScript, and do not require the D3 library yet (although `fromLatLngToPoint` does expect a Google Map instance as a parameter):

```javascript
export const numOfSamples = 100
export const metersToMiles = m => m * 0.000621371
export const metersToFeet = m => m * 3.28084

export const arraysEqual = (arr1, arr2) => {
  if (arr1.length !== arr2.length) return false
  for (let i = arr1.length; i--; ) {
    if (arr1[i] !== arr2[i]) return false
  }
  return true
}

export const fromLatLngToPoint = (latLng, map) => {
  const topRight = map
    .getProjection()
    .fromLatLngToPoint(map.getBounds().getNorthEast())
  const bottomLeft = map
    .getProjection()
    .fromLatLngToPoint(map.getBounds().getSouthWest())
  const scale = Math.pow(2, map.getZoom())
  const worldPoint = map.getProjection().fromLatLngToPoint(latLng)
  const point = new window.google.maps.Point(
    (worldPoint.x - bottomLeft.x) * scale,
    (worldPoint.y - topRight.y) * scale
  )
  return point
}
```

We export these because ideally we’re putting them in a separate `utils.js` file, to be imported as needed in our `ElevationGraph` component.

The first, `numOfSamples`, is a constant; we will be using the number of samples in a few places, so it’s easier to change later because we declare it in a single place. We choose 100 samples along our pathline because it makes the math easy. For example, if our area chart is 600 pixels wide, then we need to divide it up into 6px sections and create a hover event over each to dynamically render a point or “blip” on the map to show the user exactly where on the path she would encounter the elevation and grade our Infobox shows her.

The next two are functions we will use to do unit conversion. The Google Maps Elevation and Distance APIs return us meters, but since we do things backwards in the States, we need to convert those to miles and feet so our user doesn’t have to do conversions herself.

`arraysEqual` returns true if 2 arrays contain the same elements and false if they don’t.

We will come back to `fromLatLngToPoint` toward the end of the article — in a nutshell, it takes a `LatLng` object and a Google Map instance and does a lookup to see where a particular coordinate exists on the user’s screen, so we know where to draw the blip.

_Work in progress_
