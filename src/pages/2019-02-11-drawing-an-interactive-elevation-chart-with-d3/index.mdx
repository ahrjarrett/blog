---
path: "/2019-02-11-draw-an-interactive-elevation-chart-with-d3-and-react"
date: "2019-02-11"
title: "Draw an Interactive Elevation Chart with D3 & React"
image: "/images/2019-02-11-draw-an-interactive-elevation-chart-with-d3-and-react.gif"
tags: ["react", "d3", "javascript", "google maps"]
excerpt: "Data visualization is too fun. My team made an app that consumes a user’s trip data and uses it to draw cool stuff. Here’s how we used React, D3 and Google Maps to do it."
published: true
---

import MapWithMarkers from "../../components/maps/MapWithMarkers"
import LoadMapsApi from "../../components/maps/LoadMapsApi"
import {
  markerPositionsHI,
  mapCenterHI,
  markerPositionsSF,
  mapCenterSF,
  mapCenterESP,
  markerPositionsNZ,
  mapCenterNZ
} from "../../components/maps/data"

<LoadMapsApi />

## Virtual DOM vs. the DOM

One of the first decisions we have to make when using D3 and React together is **who gets control of the DOM**. In this video [Shirley Wu does a great job explaining](https://www.youtube.com/watch?v=zXBdNDnqV2Q) when each library should get control.

<div class="box-quote">
  <p class="box-quote-p">
    Check out the project’s{" "}
    <a
      href="https://github.com/Lambda-School-Labs/LabsPT1_Backwoods"
      target="_blank"
    >
      source code on GitHub
    </a>
    , or watch the 15-second demo below!
  </p>
</div>

Shirley goes on to explain that it’s usually best to let React paint the DOM since it manages state and, presumably, the inputs to our chart will live on state.

However in our case, because we have 100 elevation samples from Google Maps API to manage (each sample a nested object containing keys such as `elevation` and `location`, which is itself an object with `latitude` and `longitude` keys), it didn't make sense from a performance standpoint to give React control of the DOM.

Even if we were to use a PureComponent to avoid doing deep comparisons and minimize re-renders, we’re still managing references to 100 objects, and 100 shallow comparisons is still 100 comparisons.

So we made the decision to store things like map markers on state only when absolutely necessary, and to never store our samples on state. For this reason, **we decided to let D3 control how the ElevationChart paints the DOM**.

## What We’ll Be Building

Here’s the feature we’ll be building:

<iframe
  className="youtube-video"
  width="720"
  height="480"
  src="https://www.youtube.com/embed/9HXlmXwyuKk"
  frameBorder="0"
  allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
  allowFullScreen
/>

We won’t cover adding a map, creating markers or drawing the polyline; detailed instructions for how to create those are all available in the [Google Maps Documentation](https://developers.google.com/maps/documentation/).

Assuming you’ve got your map, some markers, and a polyline path that connects them, we’re ready to build the component. This is what we need to do:

1. Get data: We’ll use Google’s Distance and Elevation APIs to create an array with 100 objects representing samples along our polyline
1. Draw the maps: Use the Google Maps API to draw a map and its parts according to the data it receives as input.
1. Draw the data: Add the D3 library and draw an SVG chart to represent this data visually
1. Draw the infobox: When a user hovers over the chart, we show the user the Elevation and Grade at that point
1. Draw the blip: Based on where the user hovers, we need to draw a blip (almost a marker, but not quite) on the map at that point along the path

Are you excited? I am too. Let’s get started.

## 1. Get Data

Let’s look at the docs for the Google Maps [Elevation API](https://developers.google.com/maps/documentation/elevation) to see what we’ll be working with.

From the [Google Map Docs](https://developers.google.com/maps/documentation/elevation/intro):

<div class="box-quote">
  <p class="box-quote-p">
    ...you may request sampled elevation data along paths, allowing you to
    calculate elevation changes along routes.
  </p>
</div>

This is exactly what we need to do!

**Note:** See the [docs on the LatLng class](https://developers.google.com/maps/documentation/javascript/reference/coordinates#LatLng) and the [Marker API](https://developers.google.com/maps/documentation/javascript/markers) for more info on the Google Maps objects we’ll be working with.

Let’s define a class method called `getElevationsAlongPath` that handles this:

```jsx
import React from "react"

const calcDistance = (
  { lat: fromLat, lng: fronLng },
  { lat: toLat, lng: toLng }
) => {
  // IMPURE! assumes google is available on the window object:
  return window.google.maps.geometry.spherical.computeDistanceBetween(
    new window.google.maps.LatLng(fromLat, fromLng),
    new window.google.maps.LatLng(toLat, toLng)
  )
}

export default class ChartWrapper extends React.Component {
  state = {
    distances: [],
    elevations: [],
    markers: [],
  }

  // componentDidMount() { ... }
  // componentDidUpdate(prevProps, prevState) { ... }

  getElevationsAlongPath = () => {
    if (this.state.markers.length > 1) {
      const elevator = new window.google.maps.ElevationService()
      const latLngs = this.state.markers.map(marker => ({
        lat: marker.getPosition().lat(),
        lng: marker.getPosition().lng()
      }))

      const { distances } = latLngs.reduce(
        (acc, curr, i, arr) => {
          if (i === arr.length - 1) return acc
          const distances = acc.distances.concat(
            // use the helper function we defined above:
            calcDistance(
              { lat: curr.lat, lng: curr.lng },
              { lat: arr[i + 1].lat, lng: arr[i + 1].lng }
            )
          )
          return distances
        },
        { distances: [] }
      )

      // API call to get our elevations:
      elevator.getElevationAlongPath(
        {
          path: latLngs,
          samples: 100
        },
        results => {
          this.setState({
            distances,
            // we’ll probably want to change the data shape later:
            elevations: results.map(result => result)
          })
        }
      )
    }
  }

  render() {
    return (
      // ...
    )
  }
}
```

[See the source code here!](https://github.com/Lambda-School-Labs/LabsPT1_bkwds/blob/master/client/src/components/Maps/SingleTrip/TripPanel.js#L75)

Let’s talk through it.

**First**, `calcDistance` is a helper function that takes 2 objects of shape `{lat: number, lng: number}` and returns the distance between them in meters.

However, if we have 5 markers, there will be 4 distance calculations between them. Having 2 arrays of unequal lengths complicates things, so we initialize the first distance to 0 (lines 36-42).

Now we have 5 markers and 5 distances and we don’t have to do maths later.

**Second**, in lines 49-61 we call the Elevations API, passing in the path we want to take samples from along with the number of samples we want. We ask for 100 samples because again, math is hard (also because I like the way these zeroes look: **0**).

When we call our method (in our case, inside `componentDidUpdate`), our `ChartWrapper` state will look something like this:

```javascript
{
  distances: [3080.666166039471, 2841.623465928883, /* ... */ ],
  markers: [<GoogleMapsMarkerObject>, <GoogleMapsMarkerObject>, /* ... */ ]
  elevations: [
    {
      elevation: 149.1212768554688,
      location: <GoogleMapsLatLngClass>,
      resolution: 9.543951988220215,

    },
    {
      elevation: 152.5092315673828,
      location: <GoogleMapsLatLngClass>,
      resolution: 9.543951988220215,
    },
    // 98 more elevations...
  ]
}
```

Success! ✨ Let’s start drawing.

## 2. Drawing the Maps

First we’ll render a simple map, because we need to make sure our API key is working and because it’s fun.

### Basic Map with Layer

Let’s start with Madrid. We can use the TransitLayer API to sketch out the arteries of the Metro de Madrid public transit system while we’re at it.

<MapWithMarkers
  type="basic"
  layer="transit"
  mapTypeId="roadmap"
  center={mapCenterESP}
  title="Metro de Madrid"
  theme="day"
  zoom={13.6}
/>

_Sí, tú estás luciendo bien allí, Madrid._

<div class="box-quote">
  <p class="box-quote-p">
    The Madrid Metro is a rapid transit system serving the city of Madrid,
    capital of Spain. The system is the 12th longest rapid transit system in the
    world, with a total length of 293 km, though Madrid is approximately the
    fiftieth most populous metropolitan area in the world.
    <br />– Wikipedia
  </p>
</div>

### Bounded Map with Markers & Polyline

Next we need to draw some markers and connect them by a path (or “polyline”, in Google-Maps-speak). We can’t use the Directions API without a Premium account, and last I checked it takes \$10K to open one of those. So our polyline will be an approximation of a user’s trajectory rather than a shortest path implementation.

In the app our team build, we rendered this data dynamically based on user input. Dropping, dragging and deleting markers and then updating map state is not the focus of this post, besides I’m sure you already have ideas about how you would go about doing that. Check out our repo if you’d like to see how we did it.

We’re going to keep hardcoding values for now, but we’ll switch it up to keep things lively. Let’s go to San Francisco because I can’t afford to go in real life anymore:

<MapWithMarkers
  type="markersAndPolyline"
  center={mapCenterSF}
  markerPositions={markerPositionsSF}
  zoom={12.8}
  mapTypeId="roadmap"
  theme="comic"
  title="Lombard Street, SF"
/>

Great! We now have 18 markers representing a stroll down Lombard Street.

Notice how clicking show adjusts the map’s zoom and bounds to neatly frame the markers, while hiding them returns our map to its initial state.

Here’s the method that builds up a `LatLngBounds` object for us and then adjusts our map’s “lens” to contain it:

```javascript
class MyMapComponent extends React.Component {
  setMapBounds = (map, positions) => {
    let bounds = new window.google.maps.LatLngBounds()
    positions.forEach(p => {
      const bound = p.position
        ? { lat: p.position.lat(), lng: p.position.lng() }
        : { lat: p.lat, lng: p.lng }
      bounds.extend(bound)
    })
    map.fitBounds(bounds)
  }

  render() {
    /* ... */
  }
}
```

**Lines 5-7:** If you’ve worked with the GM API for any length of time, you’ve probably gotten tired of keeping track of whether you’re dealing with an instance of the LatLng class — where latitude, for example, is accessible by calling the function `LatLng.position.lat()`.

We got tired of converting back and forth, so we wrote `setMapBounds` to accept either type. For every coordinate object or LatLng instance we pass in, we adjust the outer bounds of our map, and finally we fit the map to those boundaries.

Drawing the polyline is as simple as:

```javascript
class MyMapComponent extends React.Component {
  polyline = null
  drawPath = (map, markers) => () => {
    const path = markers.map(marker => ({
      lat: marker.getPosition().lat(),
      lng: marker.getPosition().lng()
    }))
    const polyline = new window.google.maps.Polyline({
      path,
      strokeColor: "#000c3c",
      strokeOpacity: 1,
      strokeWeight: 2.5
    })
    this.polyline = polyline
    polyline.setMap(map)
    this.setState({ showPath: true })
  }

  render() {
    /* ... */
  }
}
```

Notice that we did not make this method as flexible as `setMapBounds` w/r/t its arguments; we learned the hard way that drawing and especially _redrawing_ polylines to be slightly more finicky, and did not feel like it needed _more_ flexibility as much as it needed proper documentation of its function signature.

**Line 14:** We add the polyline to our class for use throughout the rest of the component. We also need to keep track of it so we can remove it later when the user clicks “Hide Path” (“Hide Markers” too, otherwise we’d have a marker-less path floating around with nothing anchoring it down!).

Now let’s get those elevation samples.

### Map Showing Elevation at Locations

<MapWithMarkers
  type="elevationForLocations"
  center={mapCenterHI}
  markerPositions={markerPositionsHI}
  title="Waipio Rd – Waimea, Hawaii"
  theme="retro"
  showDeltas={true}
  zoom={13.7}
/>

### Map Fetching Elevation Samples Along Path

Instead of getting the difference in elevation between each point, we can ask for `n` number of elevation samples along a path. Requesting 100 samples along a polyline, for example, is a relatively cheap request (1 API call) for how much data we get, and our area chart will be much more granular for it.

<MapWithMarkers
  type="elevationAlongPath"
  center={mapCenterNZ}
  markerPositions={markerPositionsNZ}
  title="Baldwin St – Dunedin, NZ"
  theme="retro"
  zoom={13.8}
/>

To see the raw data that the Google Maps API is returning, click “Elevation Samples” and check your console for the green log:

<img src="/images/console_results.png" alt="console results" />

[Elevation Chart Styles](https://github.com/Lambda-School-Labs/LabsPT1_bkwds/blob/master/client/src/styles/ElevationChart.styles.js#L82)

```jsx
import React, { Component } from "react"
import * as d3 from "d3"

import ChartIcon from "./icons/ChartSvg"
import * as s from "../styles/ElevationChart.styles"

const margin = { top: 0, right: 0, bottom: 15, left: 50 }
const width = 750 - margin.left - margin.right
const height = 155 - margin.top - margin.bottom
const xAxisTicks = 8
const yAxisTicks = 6

export const numOfSamples = 100
export const metersToMiles = m => m * 0.000621371
export const metersToFeet = m => m * 3.28084
```

## 3. Drawing the data
