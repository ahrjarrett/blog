---
path: "/2019-03-27-draw-an-interactive-elevation-chart-with-d3-and-react-pt-3"
date: "2019-03-27"
title: "Draw an Interactive Elevation Chart with D3 & React, Part 3"
image: "2019-03-27-draw-an-interactive-elevation-chart-with-d3-and-react-pt-3.gif"
sharpImage: false
imgOverlay: "linear-gradient(to top, rgba(195, 20, 50, 0.75), rgba(36, 11, 54, 0.75))"
tags: ["react", "d3", "javascript", "google maps", "data-visualization"]
excerpt: "Part 3: Data visualization is too fun. My team made an app that consumes a user‚Äôs trip data and uses it to draw cool stuff. Here‚Äôs how we used React, D3 and Google Maps to do it."
published: true
---

import * as d3 from "d3"
import Chart from "../../components/d3/Chart"
import LoadMapsApi from "../../components/maps/LoadMapsApi"
import MapWithMarkers from "../../components/maps/MapWithMarkers"
import MapDrawn from "../../components/maps/MapDrawn"

import data from "../../components/d3/data"
import {
  mapCenterNZ,
  mapCenterCZ,
  mapCenterEverest,
  markerPositionsNZ,
  markerPositionsCZ,
  markerPositionsEverest
} from "../../components/maps/data"

<LoadMapsApi />

##### _Image credit above goes to [furryhead](https://www.behance.net/furryhead), see the [original creative here](https://www.behance.net/gallery/29307801/2001-A-Space-Odyssey-animated-Gif)._

This is part 3 of a 3-part series about using Google Maps and D3 to create an elevation graph that responds dynamically with user interaction. Here are all 3 posts:

- [Part 1: Google Maps](/posts/2019-02-11-draw-an-interactive-elevation-chart-with-d3-and-react)
- [Part 2: D3 for Data Visualization](/posts/2019-02-16-draw-an-interactive-elevation-chart-with-d3-and-react)
- [Part 3: Creating User Interaction](/posts/2019-03-27-draw-an-interactive-elevation-chart-with-d3-and-react-pt-3)

In this section, we‚Äôll finish building this. Try hovering over the graph to see how our users can interact with this component!

<MapDrawn
  type="withChart"
  center={mapCenterCZ}
  markerPositions={markerPositionsCZ}
  title="Prague"
  theme="retro"
  zoom={11}
  height={400}
  width={553}
/>

<Chart
  type="withMap"
  targetNode={"#chart6"}
  data={data.fakeData6}
  transform="translate(47.5, 5)"
  ticks={true}
  gridlines={true}
  lineColor="84, 53, 16"
  fillColor="131, 140, 94"
  background="#fff"
  mapName="__map__Prague"
  height={200}
  width={550}
  viewBox="0 0 525 175"
>
  <div id="chart6" />
</Chart>

Alright. Let‚Äôs get started.

## Creating User Interaction

In this part (part 3), we‚Äôll be connecting our Map and Graph components, updating them both dynamically based on user input.

Here is where we left off in Part 1:

<MapWithMarkers
  type="elevationAlongPath"
  center={mapCenterNZ}
  markerPositions={markerPositionsNZ}
  title="Baldwin St ‚Äì Dunedin, NZ"
  theme="night"
  zoom={13.8}
/>

On the map above, go ahead and click:

1. `Show Markers` ‚Äì>
2. `Draw Path` ‚Äì>
3. `Elevation Samples`

and then check your console to see what the response from the Google API looks like.

(In case you‚Äôre on mobile, here‚Äôs a sample of the elevations that the Google Maps API returns to us:)

```javascript
{elevation: 35.52785110473633, location: _.P, resolution: 19.08790397644043}
{elevation: 35.73416519165039, location: _.P, resolution: 19.08790397644043}
// 96 more...
{elevation: 80.05186462402344, location: _.P, resolution: 19.08790397644043}
```

We can ignore the resolution field for now, and we‚Äôll discuss what the `_.P` value means soon.

> _Remember_: We asked for 100 samples along our pathline, so we‚Äôre working with 100 data points, not just the 6 markers that display in our map!

And here is where we left off in Part 2:

<Chart
  targetNode={"#chart5"}
  data={data.fakeData5}
  transform="translate(47.5, 5)"
  ticks={true}
  gridlines={true}
  lineColor="26, 44, 46"
  fillColor="103, 148, 115"
  background="rgb(144, 153, 167, 0.15)"
>
  <div id="chart5" />
</Chart>

Cool! So what‚Äôs next?

Next we‚Äôre going to connect our map and our elevation chart so when a user hovers over the chart, a ‚Äúblip‚Äù appears dynamically on the map to show the user where on the map the user will experience that particular elevation.

Let‚Äôs jump right in! ‚ú®

## Getting Our Distances

So we have our elevations, but how do we get distances? We need 100 of them to populate the x-axis so our every elevation on the y-axis maps to a corresponding value.

For our purposes, each distances will represent how far that elevation sample is from the starting point, which is our first map marker.

We will also need to keep a reference to the map around so we can ask it where a particular longitude and latitude is on the map (that way we know where on the screen to draw our ‚Äúblip‚Äù).

Our component‚Äôs signature should look like this when we‚Äôre done:

```jsx
<Chart
  elevations={this.state.elevations}
  markers={this.state.markers}
  mapName={this.props.mapRef}
/>
```

Where `map` is a reference to our Google Maps instance, `markers` are the Google Map Markers that together comprise our polyline, and elevations` is an array of 100 objects with the following shape:

```javascript
{
  elevation: float!
  location: LagLng
  resolution: float!
}
```

So how are we going to get those distances?

First we have to talk about what the `_.P` thing is.

### Getting an Elevation‚Äôs Coordinates

The `_.P` value that you see at the `location` key is an instance of the Google Maps `LatLng` class [see the docs on LatLng (ADD!)](brokenlink).

We can use this object to get an elevation‚Äôs corresponding latitude and longitude coordinates.

> **That the Elevations API returns a `LatLng` instance is the key to making all of this work.**

If we want to get the coordinates of our first object in our `Chart` component, we do:

```jsx
class Chart extends React.Component {
  render() {
    return (
      <div>
        <p>1st Elevation Latitude: {this.props.data[0].location.lat()}</p>
        <p>1st Elevation Longitude: {this.props.data[0].location.lng()}</p>
      </div>
    )
  }
}
```

Among other things, the `LatLng` class comes with 2 methods that simply return the latitude or longitude value they‚Äôre holding.

#### Test it out yourself!

If you want to test it out yourself, I‚Äôve added the map above to `window` at this address:

`window.__map__Baldwin_St___Dunedin__NZ`

If you open the console, you can run any method you‚Äôd like. Try running:

```javascript
window.__map__Baldwin_St___Dunedin__NZ.center.lat() // -45.849184470199674
window.__map__Baldwin_St___Dunedin__NZ.center.lng() // 170.5342357575057
```

Those are the coordinates for the center of our map! `GoogleMap.center` is an instance of the `LatLng` class.

Okay, so we can get coordinates. But we‚Äôre creating an area chart (basically a line graph with shading under the line), which means our x-axis needs to represent a scale (do you remember [what kind of scale?](https://github.com/d3/d3-scale#linear-scales)).

Our `xScale` is distance from the polyline‚Äôs point of origin, _along the polyline_. This is important because we‚Äôre assuming that the polyline represents a user‚Äôs trip, and so a particular point on our graph tells us _how far along the trip_ the user can expect to encounter a particular elevation.

**Scales:**

- `x: distance from origin along polyline`
- `y: elevation at point`

### Getting Our Distances

At first we struggled with this. The Google Maps API does allow you to pass an ‚Äúarray‚Äù of coordinate pairs and returns an array of distance results, _but we‚Äôd only be getting the beeline distance_, which is different than what we‚Äôre after.

To get around this, we decided to calculate the distance between each marker to come up with the total distance along our pathline, then divide that number by 100.

Although this isn‚Äôt 100% perfect, Google Maps‚Äô `getElevationsAlongPath` function returns as many samples as you ask for along the polyline that you pass it.

It‚Äôs not perfect because Google Maps approximates, rather than calculates the elevation, based on the surrounding topography (the `resolution` key gives us a sense of how accurate the return value is).

But it‚Äôs pretty damn close, so we considered our users and decided that and we‚Äôre comfortable with the tradeoff:

Lower app complexity, occasionally slight inaccuracies.

That means we can divide our distance by our number of samples to get a unit, and then multiply the unit by the elevation‚Äôs index to get the distance from the point of origin.

```javascript
export const numOfSamples = 100
const startDistance = 0
const endDistance = distances.reduce((acc, curr) => acc + curr, startDistance)
const sampleUnit = endDistance / numOfSamples

const makeData = data =>
  data.reduce((acc, curr, i) => {
    const dist = sampleUnit * (i + 1)
    return acc.concat({ x: dist, y: curr.elevation, ...curr })
  }, [])
```

Calling `makeData` and passing in our array of elevations that we received on props, we get an array of data with this shape:

```javascript
{
  x: float! // distance from origin in meters along path
  y: float! // elevation in meters at point
  location: LagLng!
  resolution: float!
}
```

There! We have our distances.

## Get Screen Coordinates

But there‚Äôs one big problem we haven‚Äôt solved:

**How are we supposed to draw our ‚Äúblip‚Äù on the map?**

At first we tried using the Marker API to create a marker from a given location, only to destroy it and redraw a new one when the user‚Äôs mouse moves.

That ended up creating a very choppy user experience, not to mention the event handler was lossy -- the Markers API was not called, so sometimes a marker would render and sometimes it would not be deleted.

However it wasn‚Äôt hard to do. Each elevation comes with coordinates, so it was as simple as doing `new google.maps.Marker(...)` and passing in the coordinates.

Video of our first iteration -- you can tell we were starting to have fun.

<iframe
  className="youtube-video"
  width="720"
  height="480"
  src="https://www.youtube.com/embed/IKNc7kCjEc8"
  frameBorder="0"
  allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
  allowFullScreen
/>

So markers were out.

As far as we could ascertain, the Markers API was the only way to render an element at a particular point on the map. Sure, technically we could add other SVG elements to the map, but would all suffer from the same choppiness.

We poured over the Google Maps documentation, looking for an escape hatch. Some way to ‚Äúmap‚Äù a set of coordinates that exist on the map canvas to its corresponding set of coordinates in the browser window.

Finally we started playing around with the [Point class](https://developers.google.com/maps/documentation/javascript/reference/coordinates#Point), which represents a point on a two-dimensional plane.

From there we found the `fromLatLngToPoint` class, and Googling for the docs led us to this short, wonderful [blog post by Krasimir Tsonev](http:// krasimirtsonev.com/blog/article/google-maps-api-v3-convert-latlng-object-to-actual-pixels-point-object).

```javascript
const fromLatLngToPoint = (latLng, map) => {
  const topRight = map
    .getProjection()
    .fromLatLngToPoint(map.getBounds().getNorthEast())
  const bottomLeft = map
    .getProjection()
    .fromLatLngToPoint(map.getBounds().getSouthWest())
  const scale = Math.pow(2, map.getZoom())
  const worldPoint = map
    .getProjection()
    .fromLatLngToPoint(new window.google.maps.LatLng(latLng))
  const point = new window.google.maps.Point(
    (worldPoint.x - bottomLeft.x) * scale,
    (worldPoint.y - topRight.y) * scale
  )
  return point
}
```

The `scale = Math.pow(2, map.getZoom())` was exactly what we needed to make the conversion.

Because we pass the map as an argument each time, _even if the user drags or zooms the map between calls **we always get the fresh and current screen x- and y-coordinates at a given position**_.

Almost done. Now that we know _where_ to draw the blip, let‚Äôs draw it.

### Drawing the ‚ÄúBlip‚Äù

We‚Äôll draw the blip in our `mousemove` function:

```javascript
function mousemove() {
  const x0 = xScale.invert(d3.mouse(this)[0])
  const i = bisect(data, x0, 1)
  const d0 = data[i - 1]
  const d1 = data[i]
  const d = !d1 ? d0 : x0 - d0.x > d1.x - x0 ? d1 : d0
  crossBar.attr("transform", `translate(${xScale(d.x)}, 0)`)
  crossBar.select("text").text(d3.format(".1f")(metersToMiles(d.x)) + "mi")
  infoBox.attr("transform", `translate(${xScale(d.x) + 10}, 12.5)`)
  infoBox
    .select(".infoBoxElevationValue")
    .text(d3.format(",.0f")(metersToFeet(d.y)) + "ft")

  /*** BEGIN NEW STUFF ***/
  const { x: px, y: py } = fromLatLngToPoint(d.location, this.state.map)
  blip.style("transform", `translate3d(${px}px, ${py}px, 0px)`)
  /*** END NEW STUFF ***/

  return null
}
```

Finally, we need to toggle the blip‚Äôs display in our `mouseover` and `mouseleave` events. We just have to add 2 lines of code to do it:

```javascript
svg
  .append("rect")
  .attr("class", "chartOverlay")
  .attr("width", this.width)
  .attr("height", this.height)
  .on("mouseover", function() {
    crossBar.style("display", null)
    infoBox.style("display", null)
    /*** NEW LINE ***/
    blip.style("display", null)
  })
  .on("mouseout", function(e) {
    crossBar.style("display", "none")
    infoBox.style("display", "none")
    /*** NEW LINE ***/
    blip.style("display", "none")
  })
  .on("mousemove", mousemove)
```

And that‚Äôs it! We‚Äôve done it üíØ

<MapDrawn
  type="withChart"
  center={mapCenterEverest}
  markerPositions={markerPositionsEverest}
  title="Mt. Everest"
  theme="retro"
  zoom={13}
  height={400}
  width={553}
/>

<Chart
  type="withMap"
  targetNode={"#chart7"}
  data={data.fakeData7}
  transform="translate(47.5, 5)"
  ticks={true}
  gridlines={true}
  lineColor="84, 53, 16"
  fillColor="131, 140, 94"
  background="#fff"
  mapName="__map__Mt__Everest"
  height={200}
  width={550}
  viewBox="0 0 525 175"
>
  <div id="chart7" />
</Chart>

Check out the [component as we originally wrote it here](https://github.com/Lambda-School-Labs/LabsPT1_bkwds/blob/master/client/src/components/ElevationChart.js).

Thanks for reading! These components were part of our capstone project at Lambda School. If you have any questions about the project or my experience at Lambda School, feel free to reach out to me at <a href="mailto:ahrjarrett@gmail.com">ahrjarrett@gmail.com</a>.
